{"version":3,"file":"common-ea4e35ceaa533377b6d9.js","mappings":";;;;;;;;;;;;;;;AAmCA;AACA;;;AAKA;ACfA;AACA;;AAIA;;;AAGA;AAEA;;;;AAOA;;AAIA;AACA;AACA;;;AAGA;;;;;;;AASA;;ACxCA;;;;ACFA;;ACaA;;AAIA;;ACnBA;;;;;AAKA;;;AAKA;;AAIA;;;;;;;;ACbA;;;;ACCA;;;;AAMA;;ACuBA;AACA;;;;;;;AAOA;;;;;;;;;;;AAuBA;;AAEA;;;;;AASA;;AAIA;;;;;;AAMA;;;;;;AAQA;;;;;;;;;AAWA;;AA0GA;AAGA;;;AAGA;;AAIA;;;;;AAOA;;;AAKA;;;AAKA;;;;;;;;AAQA;AAGA;;;;;;;AASA;;;AAKA;;AAKA;;;;;;;;;;;;;AAeA;;;;AAMA;;;;;AAOA;;;;;AAOA;;;;AAMA;;;;AAsLA;;;;;;;;ACheA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;AAoBA;;;;AAIA;;;AAGA;;;;AAIA;;AAIA;;;;AAMA;;;;AAMA","sources":["webpack://@ringcentral-integration/jsonschema-page/./src/Widgets/CheckboxWidget.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Widgets/RadioWidget.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Widgets/RangeWidget.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Widgets/TextareaWidget.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Widgets/FileWidget.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Templates/TitleField.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Fields/Alert.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/components/ActionMenu.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Fields/List.tsx","webpack://@ringcentral-integration/jsonschema-page/./src/Fields/Search.tsx"],"sourcesContent":["import React, { FocusEvent } from 'react';\nimport {\n  RcSwitch,\n  styled,\n  css,\n}from '@ringcentral/juno';\nimport {\n  ariaDescribedByIds,\n  descriptionId,\n  getTemplate,\n  labelValue,\n  schemaRequiresTrueValue,\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  WidgetProps,\n} from '@rjsf/utils';\n\nconst SwitchContainer = styled.div`\n  width: 100%;\n\n  .MuiFormControlLabel-label {\n    flex: 1;\n  }\n\n  .MuiFormControlLabel-root {\n    margin-left: 0;\n    width: 100%;\n  }\n\n  .RcSwitch-root {\n    margin: 2px;\n  }\n`;\n\nconst StyledSwitch = styled(RcSwitch)`\n  ${(props) => props.readOnly && css`\n    opacity: 0.5;\n  `}\n`;\n\nexport default function CheckboxWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(props: WidgetProps<T, S, F>) {\n  const {\n    schema,\n    id,\n    value,\n    disabled,\n    readonly,\n    label = '',\n    hideLabel,\n    autofocus,\n    onChange,\n    onBlur,\n    onFocus,\n    registry,\n    options,\n    uiSchema,\n  } = props;\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\n    'DescriptionFieldTemplate',\n    registry,\n    options\n  );\n  // Because an unchecked checkbox will cause html5 validation to fail, only add\n  // the \"required\" attribute if the field value must be \"true\", due to the\n  // \"const\" or \"enum\" keywords\n  const required = schemaRequiresTrueValue<S>(schema);\n\n  const _onChange = (_: any, checked: boolean) => onChange(checked);\n  const _onBlur = ({ target: { value } }: FocusEvent<HTMLButtonElement>) => onBlur(id, value);\n  const _onFocus = ({ target: { value } }: FocusEvent<HTMLButtonElement>) => onFocus(id, value);\n  const description = options.description ?? schema.description;\n\n  return (\n    <>\n      {!hideLabel && !!description && (\n        <DescriptionFieldTemplate\n          id={descriptionId<T>(id)}\n          description={description}\n          schema={schema}\n          uiSchema={uiSchema}\n          registry={registry}\n        />\n      )}\n      <SwitchContainer>\n        <StyledSwitch\n          id={id}\n          name={id}\n          checked={typeof value === 'undefined' ? false : Boolean(value)}\n          required={required}\n          disabled={disabled || readonly}\n          autoFocus={autofocus}\n          onChange={_onChange}\n          onBlur={_onBlur}\n          onFocus={_onFocus}\n          aria-describedby={ariaDescribedByIds<T>(id)}\n          formControlLabelProps={{\n            labelPlacement: 'start',\n          }}\n          label={labelValue(label, hideLabel, false)}\n          readOnly={readonly}\n        />\n      </SwitchContainer>\n    </>\n  );\n}\n","import React, { FocusEvent } from 'react';\nimport {\n  RcFormControlLabel as FormControlLabel,\n  RcFormLabel as FormLabel,\n  RcRadio as Radio,\n  RcRadioGroup as RadioGroup,\n  RcTabs as Tabs,\n  RcTab as Tab,\n  styled,\n  css,\n  palette2,\n} from '@ringcentral/juno';\n\nimport {\n  ariaDescribedByIds,\n  enumOptionsIndexForValue,\n  enumOptionsValueForIndex,\n  labelValue,\n  optionId,\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  WidgetProps,\n} from '@rjsf/utils';\n\nconst StyledRadioGroup = styled(RadioGroup)<{$flexDirection: string}>`\n  ${({ $flexDirection }) => $flexDirection && css`\n    flex-direction: ${$flexDirection};\n  `}\n`;\n\nconst StyledRadio = styled(Radio)<{ $iconColor: string }>`\n  .RadioButtonIcon-root {\n    .MuiSvgIcon-root {\n      ${\n        ({ $iconColor }) => $iconColor && css`\n          fill: ${$iconColor};\n        `\n      }\n    }\n  }\n`;\n\nconst StyledFormLabel = styled(FormLabel)`\n  font-size: 0.75rem;\n`;\n\nconst StyledTabs = styled(Tabs)`\n  background: ${palette2('neutral', 'b01')};\n  border-bottom: 1px solid ${palette2('neutral', 'l02')};\n\n  .RcTab-selected .tab-unread {\n    color: ${palette2('tab', 'selected')};\n    font-weight: 700;\n  }\n\n  .MuiTab-root {\n    padding: 6px 10px;\n  }\n`;\n\nexport default function RadioWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\n  id,\n  options,\n  value,\n  required,\n  disabled,\n  readonly,\n  label,\n  hideLabel,\n  onChange,\n  onBlur,\n  onFocus,\n  uiSchema,\n}: WidgetProps<T, S, F>) {\n  const { enumOptions, enumDisabled, emptyValue } = options;\n\n  const _onChange = (_: any, value: any) => onChange(enumOptionsValueForIndex<S>(value, enumOptions, emptyValue));\n  const _onBlur = ({ target: { value } }: FocusEvent<HTMLInputElement>) =>\n    onBlur(id, enumOptionsValueForIndex<S>(value, enumOptions, emptyValue));\n  const _onFocus = ({ target: { value } }: FocusEvent<HTMLInputElement>) =>\n    onFocus(id, enumOptionsValueForIndex<S>(value, enumOptions, emptyValue));\n\n  const row = options ? options.inline : false;\n  const selectedIndex = enumOptionsIndexForValue<S>(value, enumOptions) ?? null;\n  const flexDirection = uiSchema['ui:itemDirection'];\n  const showValueLabel = typeof uiSchema['ui:valueLabel'] === 'undefined' ? true : uiSchema['ui:valueLabel'];\n  const tabView = uiSchema['ui:tab'];\n  if (tabView) {\n    return (\n      <StyledTabs\n        value={selectedIndex}\n        onChange={_onChange}\n        variant=\"fullWidth\"\n      >\n        {enumOptions.map((option, index) => {\n          const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;\n          return (\n            <Tab\n              key={index}\n              label={option.label}\n              value={String(index)}\n              disabled={disabled || itemDisabled || readonly}\n            />\n          );\n        })}\n      </StyledTabs>\n    );\n  }\n  return (\n    <>\n      {labelValue(\n        <StyledFormLabel required={required} htmlFor={id}>\n          {label || undefined}\n        </StyledFormLabel>,\n        hideLabel\n      )}\n      <StyledRadioGroup\n        id={id}\n        name={id}\n        value={selectedIndex}\n        row={row as boolean}\n        onChange={_onChange}\n        onBlur={_onBlur}\n        onFocus={_onFocus}\n        aria-describedby={ariaDescribedByIds<T>(id)}\n        $flexDirection={flexDirection}\n      >\n        {Array.isArray(enumOptions) &&\n          enumOptions.map((option, index) => {\n            const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;\n            const radio = (\n              <FormControlLabel\n                control={\n                  <StyledRadio\n                    name={id}\n                    id={optionId(id, index)}\n                    color={option.schema?.color}\n                    $iconColor={option.schema?.color}\n                    useRcTooltip\n                    title={option.label}\n                  />}\n                label={showValueLabel ? option.label : undefined}\n                value={String(index)}\n                key={index}\n                disabled={disabled || itemDisabled || readonly}\n              />\n            );\n\n            return radio;\n          })}\n      </StyledRadioGroup>\n    </>\n  );\n}","import React, { FocusEvent } from 'react';\nimport {\n  RcFormLabel as FormLabel,\n  RcSlider as Slider,\n  styled,\n} from '@ringcentral/juno';\n\nimport {\n  ariaDescribedByIds,\n  labelValue,\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  WidgetProps,\n  rangeSpec,\n} from '@rjsf/utils';\n\nconst StyledFormLabel = styled(FormLabel)`\n  font-size: 0.75rem;\n`;\n\nexport default function RangeWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  props: WidgetProps<T, S, F>\n) {\n  const { value, readonly, disabled, onBlur, onFocus, options, schema, onChange, required, label, hideLabel, id } =\n    props;\n  const sliderProps = { value, label, id, name: id, ...rangeSpec<S>(schema) };\n\n  const _onChange = (_: any, value?: number | number[]) => {\n    onChange(value ?? options.emptyValue);\n  };\n  const _onBlur = ({ target: { value } }: FocusEvent<HTMLInputElement>) => onBlur(id, value);\n  const _onFocus = ({ target: { value } }: FocusEvent<HTMLInputElement>) => onFocus(id, value);\n\n  return (\n    <>\n      {labelValue(\n        <StyledFormLabel required={required} htmlFor={id}>\n          {label || undefined}\n        </StyledFormLabel>,\n        hideLabel\n      )}\n      <Slider\n        disabled={disabled || readonly}\n        onChange={_onChange}\n        onBlur={_onBlur}\n        onFocus={_onFocus}\n        valueLabelDisplay='auto'\n        {...sliderProps}\n        aria-describedby={ariaDescribedByIds<T>(id)}\n      />\n    </>\n  );\n}\n","import React, { ChangeEvent, FocusEvent } from 'react';\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  WidgetProps,\n  labelValue,\n} from '@rjsf/utils';\nimport {\n  RcTextarea,\n  styled,\n} from '@ringcentral/juno';\n\nconst StyledTextarea = styled(RcTextarea)`\n  .RcTextFieldInput-input {\n    font-size: 1rem;\n  }\n`;\n\nexport default function TextareaWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(props: WidgetProps<T, S, F>) {\n  const {\n    options,\n    id,\n    label,\n    hideLabel,\n    placeholder,\n    required,\n    readonly,\n    disabled,\n    autofocus,\n    onChange,\n    onChangeOverride,\n    onBlur,\n    onFocus,\n    value,\n    InputLabelProps,\n    rawErrors = [],\n  } = props;\n  const _onChange = ({ target: { value } }: ChangeEvent<HTMLInputElement>) =>\n    onChange(value === '' ? options.emptyValue : value);\n  const _onBlur = ({ target: { value } }: FocusEvent<HTMLInputElement>) => onBlur(id, value);\n  const _onFocus = ({ target: { value } }: FocusEvent<HTMLInputElement>) => onFocus(id, value);\n\n  let rows: string | number = 2;\n  if (typeof options.rows === 'string' || typeof options.rows === 'number') {\n    rows = options.rows;\n  }\n  return (\n    <StyledTextarea\n      id={id}\n      name={id}\n      minRows={rows}\n      label={labelValue(label, hideLabel || !label, false)}\n      autoFocus={autofocus}\n      required={required}\n      disabled={disabled || readonly}\n      fullWidth\n      value={value ? value : ''}\n      error={rawErrors.length > 0}\n      onChange={onChangeOverride || _onChange}\n      onBlur={_onBlur}\n      onFocus={_onFocus}\n      placeholder={placeholder}\n      InputLabelProps={InputLabelProps}\n    />\n  );\n}\n","import React, { ChangeEvent, useRef, useState } from 'react';\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  WidgetProps,\n  labelValue,\n} from '@rjsf/utils';\nimport {\n  RcIconButton as IconButton,\n  RcTypography as Typography,\n  styled,\n  RcBox as Box,\n  RcFormLabel as FormLabel,\n  RcList as List,\n  RcListItem as ListItem,\n  RcListItemText as ListItemText,\n  RcListItemSecondaryAction as ListItemSecondaryAction,\n} from '@ringcentral/juno';\nimport { Attachment, Delete } from '@ringcentral/juno-icon';\n\nconst StyledFileInput = styled.input`\n  display: none;\n`;\n\ntype FileInfoType = {\n  dataURL?: string | null;\n  name: string;\n  size: number;\n  type: string;\n};\n\nconst StyledFormLabel = styled(FormLabel)`\n  font-size: 0.75rem;\n`;\n\nfunction addNameToDataURL(dataURL: string, name: string) {\n  if (dataURL === null) {\n    return null;\n  }\n  return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);\n}\n\nfunction processFile(file: File): Promise<FileInfoType> {\n  const { name, size, type } = file;\n  return new Promise((resolve, reject) => {\n    const reader = new window.FileReader();\n    reader.onerror = reject;\n    reader.onload = (event) => {\n      if (typeof event.target?.result === 'string') {\n        resolve({\n          dataURL: addNameToDataURL(event.target.result, name),\n          name,\n          size,\n          type,\n        });\n      } else {\n        resolve({\n          dataURL: null,\n          name,\n          size,\n          type,\n        });\n      }\n    };\n    reader.readAsDataURL(file);\n  });\n}\n\nexport default function FileWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(props: WidgetProps<T, S, F>) {\n  const {\n    options,\n    id,\n    label,\n    hideLabel,\n    placeholder,\n    required,\n    readonly,\n    disabled,\n    onChange,\n    value,\n    schema,\n  } = props;\n\n  const fileInputRef = useRef(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Get widget options\n  const multiple = options?.multiple || schema?.type === 'array';\n  const accept = options?.accept || '*/*';\n  const maxSize = Number.parseInt(options?.maxSize as string) || 0;\n\n  // Normalize value to always be an array for easier handling\n  const files: FileInfoType[] = Array.isArray(value) ? value : value ? [value] : [];\n\n  const handleFileSelect = async (selectedFiles: FileList | null) => {\n    if (!selectedFiles || selectedFiles.length === 0) return;\n\n    setIsLoading(true);\n    const newFiles: FileInfoType[] = [];\n\n    for (let i = 0; i < selectedFiles.length; i++) {\n      const file = selectedFiles[i];\n      \n      // Check file size if maxSize is specified\n      if (maxSize && file.size > maxSize) {\n        continue; // Skip files that are too large\n      }\n\n      const fileData = await processFile(file);\n\n      newFiles.push(fileData);\n    }\n\n    let newValue;\n    if (multiple) {\n      newValue = [...files, ...newFiles];\n    } else {\n      newValue = newFiles[0] || null;\n    }\n\n    onChange(newValue);\n    setIsLoading(false);\n  };\n\n  const handleFileInputChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    await handleFileSelect(event.target.files);\n    // Reset input value to allow selecting the same file again\n    if (fileInputRef.current) {\n      fileInputRef.current.value = '';\n    }\n  };\n\n  const handleRemoveFile = (index: number) => {\n    if (multiple) {\n      const newFiles = files.filter((_, i) => i !== index);\n      onChange(newFiles.length > 0 ? newFiles : null);\n    } else {\n      onChange(null);\n    }\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  return (\n    <>\n      {labelValue(\n        <StyledFormLabel required={required} htmlFor={id}>\n          {label || undefined}\n        </StyledFormLabel>,\n        hideLabel\n      )}\n      <StyledFileInput\n        ref={fileInputRef}\n        type=\"file\"\n        accept={accept as string}\n        multiple={multiple as boolean}\n        onChange={handleFileInputChange}\n        disabled={disabled}\n      />\n      <Box display=\"flex\" flexDirection=\"row\" alignItems=\"center\" gap={1}>\n        <IconButton\n          size=\"medium\"\n          symbol={Attachment}\n          disabled={disabled || readonly || isLoading}\n          loading={isLoading}\n          color=\"neutral.f06\"\n          onClick={() => {\n            if (fileInputRef.current) {\n              fileInputRef.current.click();\n            }\n          }}\n        />\n        <Typography variant=\"body1\" color=\"neutral.f06\">\n          {(!multiple && files.length > 0) ? files[0].name : (placeholder || 'No file selected.')}\n        </Typography>\n      </Box>\n\n      {multiple && files.length > 0 && (\n        <List dense>\n          {files.map((file, index) => (\n            <ListItem key={`${file.name}-${index}`}>\n              <ListItemText\n                primary={file.name}\n                secondary={`${formatFileSize(file.size)} • ${file.type || 'Unknown type'}`}\n              />\n              <ListItemSecondaryAction>\n                <IconButton\n                  size=\"small\"\n                  onClick={() => handleRemoveFile(index)}\n                  disabled={disabled || readonly}\n                  title=\"Remove file\"\n                  symbol={Delete}\n                />\n              </ListItemSecondaryAction>\n            </ListItem>\n          ))}\n        </List>\n      )}\n    </>\n  );\n}\n","import React from 'react';\nimport {\n  RcBox as Box,\n  RcTypography as Typography,\n  RcIcon,\n  RcDivider as Divider,\n  styled,\n  css,\n} from '@ringcentral/juno';\nimport { ArrowDown2, ArrowUp2 } from '@ringcentral/juno-icon';\n\nimport { FormContextType, TitleFieldProps, RJSFSchema, StrictRJSFSchema } from '@rjsf/utils';\n\nconst StyledTitle = styled(Typography)`\n  flex: 1;\n`;\n\nconst StyledBox = styled(Box)<{ $clickable: boolean }>`\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  overflow: hidden;\n  ${({ $clickable }) => $clickable && css`\n    cursor: pointer;\n  `};\n`;\n\nconst StyledIcon = styled(RcIcon)`\n  margin: 4px 0;\n`;\n\nexport default function TitleField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\n  id,\n  title,\n  uiSchema = {},\n  extended = false,\n  onClick = undefined\n}: TitleFieldProps<T, S, F>) {\n  const collapsible = uiSchema['ui:collapsible'] || false;\n  return (\n    <StyledBox\n      id={id} mb={1} mt={1}\n      $clickable={collapsible}\n      onClick={onClick}\n    >\n      <StyledTitle variant=\"subheading1\" color=\"neutral.f06\">{title}</StyledTitle>\n      {\n        collapsible ? (\n          <StyledIcon\n            symbol={extended ? ArrowUp2 : ArrowDown2}\n            color=\"neutral.f06\"\n          />\n        ) : null\n      }\n      {\n        collapsible ? null : (<Divider />)\n      }\n    </StyledBox>\n  );\n}\n","import React from 'react';\n\nimport {\n  RcAlert,\n  styled,\n} from '@ringcentral/juno';\nimport { TextWithMarkdown } from '../components/TextWithMarkdown';\n\nconst StyledAlert = styled(RcAlert)`\n  &.RcAlert-root {\n    padding: 10px;\n  }\n\n  .RcAlert-message {\n    font-size: 0.875rem;\n  }\n`;\n\nexport function Alert({\n  schema,\n  uiSchema,\n}) {\n  return (\n    <StyledAlert severity={uiSchema && uiSchema['ui:severity'] || 'info'}>\n      <TextWithMarkdown text={schema.description} />\n    </StyledAlert>\n  );\n}\n","import React, { useState, useRef } from 'react';\nimport { styled } from '@ringcentral/juno/foundation';\nimport {\n  RcIconButton,\n  RcMenu,\n  RcMenuItem,\n  RcListItemText,\n  RcListItemIcon,\n  RcIcon,\n} from '@ringcentral/juno';\n\nimport { MoreVert } from '@ringcentral/juno-icon';\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst StyledMoreMenu = styled(RcMenu)`\n  .RcListItemText-primary {\n    font-size: 0.875rem;\n  }\n`;\n\nexport function ActionMenu({\n  actions,\n  className = undefined,\n  maxActions = 3,\n  size = undefined,\n  iconVariant = undefined,\n  color = undefined,\n  onClick = undefined,\n  onMoreMenuOpen = undefined,\n}) {\n  const [moreMenuOpen, setMoreMenuOpen] = useState(false);\n  const moreButtonRef = useRef<HTMLDivElement>(null);\n  const currentActions = actions.length > maxActions ? actions.slice(0, maxActions - 1) : actions;\n  const moreActions = actions.length > maxActions ? actions.slice(maxActions - 1) : [];\n\n  return (\n    <Container className={className} onClick={onClick}>\n      {\n        currentActions.map((action, index) => {\n          return (\n            <RcIconButton\n              key={index}\n              symbol={action.icon}\n              onClick={action.onClick}\n              size={size}\n              disabled={action.disabled}\n              title={action.title}\n              variant={iconVariant}\n              color={action.color || color}\n            />\n          );\n        })\n      }\n      {\n        moreActions.length > 0 && (\n          <RcIconButton\n            innerRef={moreButtonRef}\n            symbol={MoreVert}\n            onClick={() => {\n              setMoreMenuOpen(true);\n              onMoreMenuOpen?.(true);\n            }}\n            size={size}\n            variant={iconVariant}\n            color={color}\n          />\n        )\n      }\n      {\n        moreActions.length > 0 && (\n          <StyledMoreMenu\n            open={moreMenuOpen}\n            onClose={() => {\n              setMoreMenuOpen(false);\n              onMoreMenuOpen?.(false);\n            }}\n            anchorEl={moreButtonRef.current}\n            onClick={(e) => {\n              e.stopPropagation();\n            }}\n          >\n            {\n              moreActions.map((action, index) => {\n                return (\n                  <RcMenuItem\n                    key={index}\n                    onClick={() => {\n                      action.onClick();\n                      setMoreMenuOpen(false);\n                      onMoreMenuOpen?.(false);\n                    }}\n                    disabled={action.disabled}\n                  >\n                    <RcListItemIcon color={action.color}>\n                      <RcIcon symbol={action.icon} size=\"small\" />\n                    </RcListItemIcon>\n                    <RcListItemText primary={action.title} color={action.color} />\n                  </RcMenuItem>\n                );\n              })\n            }\n          </StyledMoreMenu>\n        )\n      }\n    </Container>\n  );\n}\n","import React, { useState } from 'react';\n\nimport {\n  RcList,\n  RcListItem,\n  RcListItemText,\n  RcListItemAvatar,\n  RcListItemSecondaryAction,\n  RcAvatar,\n  RcIcon,\n  RcCard,\n  RcCardContent,\n  RcCardActionArea,\n  RcCardActions,\n  RcTypography,\n  styled,\n  palette2,\n  css,\n  ellipsis,\n  useAvatarColorToken,\n  useAvatarShortName,\n} from '@ringcentral/juno';\n\nimport {\n  ArrowRight,\n  Edit,\n  Delete,\n  NewAction,\n  ViewBorder,\n  Copy,\n  Share,\n  Download,\n  PhoneBorder,\n  SmsBorder,\n  People,\n  Refresh,\n  InfoBorder,\n  InsertLink,\n  Connect,\n  ViewLogBorder,\n} from '@ringcentral/juno-icon';\n\nimport { ActionMenu } from '../components/ActionMenu';\n\nconst StyledList = styled(RcList)`\n  margin: 0 -16px;\n`;\n\nconst StyledItem = styled(RcListItem)<{ $hoverOnMoreMenu?: boolean }>`\n  border-bottom: 1px solid ${palette2('neutral', 'l02')};\n  cursor: pointer;\n\n  .list-item-action-menu {\n    display: none;\n  }\n\n  ${({ $hoverOnMoreMenu }) =>\n    $hoverOnMoreMenu &&\n    `\n    .list-item-action-menu {\n      display: flex;\n    }\n\n    .list-item-meta {\n      display: none;\n    }\n  `}\n\n  &:hover {\n    .list-item-action-menu {\n      display: flex;\n    }\n\n    .list-item-meta {\n      display: none;\n    }\n  }\n`;\n\nconst StyledAvatar = styled(RcAvatar)<{ $round?: boolean }>`\n  .RcAvatar-avatarContainer {\n    ${({ $round }) => \n      $round ? '' : css`\n        border-radius: 0;\n        background: transparent;\n      `\n    }\n  }\n`;\n\nconst NavigationIcon = styled(RcIcon)`\n  margin: 8px 0;\n`;\n\nconst MetaContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n\n  span {\n    ${ellipsis}\n  }\n\n  span:first-child {\n    line-height: 22px;\n  }\n`;\n\nexport const StyledActionMenu = styled(ActionMenu)`\n  position: absolute;\n  right: 16px;\n  top: 50%;\n  margin-top: -16px;\n\n  .RcIconButton-root {\n    margin-left: 6px;\n  }\n`;\n\nconst ICONS_MAP = {\n  'edit': Edit,\n  'delete': Delete,\n  'view': ViewBorder,\n  'copy': Copy,\n  'share': Share,\n  'download': Download,\n  'phone': PhoneBorder,\n  'sms': SmsBorder,\n  'people': People,\n  'refresh': Refresh,\n  'newAction': NewAction,\n  'info': InfoBorder,\n  'insertLink': InsertLink,\n  'connect': Connect,\n  'viewLog': ViewLogBorder,\n};\n\nfunction ListItem({\n  item,\n  disabled,\n  selected,\n  onClick,\n  showIconAsAvatar,\n  showAsNavigation,\n  actions = [],\n  onClickAction,\n}) {\n  const [hoverOnMoreMenu, setHoverOnMoreMenu] = useState(false);\n  const formattedActions = actions.map((action) => {\n    const icon = ICONS_MAP[action.icon];\n    return {\n      title: action.title,\n      icon: icon || ICONS_MAP.info,\n      onClick: (e) => {\n        e.stopPropagation();\n        onClickAction(action);\n      },\n      id: action.id,\n      color: action.color,\n      disabled: action.disabled,\n    };\n  });\n  return (\n    <StyledItem\n      key={item.const}\n      disabled={disabled}\n      selected={selected}\n      onClick={onClick}\n      $hoverOnMoreMenu={hoverOnMoreMenu}\n    >\n      {\n        item.icon ? (\n          <RcListItemAvatar>\n            <StyledAvatar\n              size=\"xsmall\"\n              src={item.icon || item.authorAvatar}\n              title={item.authorName}\n              $round={showIconAsAvatar}\n            />\n          </RcListItemAvatar>\n        ) : null\n      }\n      <RcListItemText\n        primary={item.title}\n        secondary={item.description}\n      />\n      {\n        (item.meta || item.authorName || showAsNavigation) ? (\n          <RcListItemSecondaryAction>\n            <MetaContainer className=\"list-item-meta\">\n              {item.authorName && <span>{item.authorName}</span>}\n              {item.meta && <span>{item.meta}</span>}\n            </MetaContainer>\n            {\n              showAsNavigation ? (\n                <NavigationIcon\n                  symbol={ArrowRight}\n                  size=\"large\"\n                />\n              ) : null\n            }\n          </RcListItemSecondaryAction>\n        ) : null\n      }\n      {\n        actions.length > 0 && (\n          <StyledActionMenu\n            actions={formattedActions}\n            size=\"small\"\n            maxActions={3}\n            className=\"list-item-action-menu\"\n            iconVariant=\"contained\"\n            color=\"neutral.b01\"\n            onMoreMenuOpen={(open) => {\n              setHoverOnMoreMenu(open);\n            }}\n          />\n        )\n      }\n    </StyledItem>\n  );\n}\n\nconst CardTitle = styled(RcTypography)`\n  height: 22px;\n  ${ellipsis}\n`;\n\nconst StyledCardBody = styled(RcTypography)`\n  margin-top: 4px;\n  height: 32px;\n  ${ellipsis}\n  white-space: break-spaces;\n`;\n\nconst StyledCard = styled(RcCard)`\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst StyledCardWrapper = styled.div`\n  padding: 4px;\n  width: 100%;\n`;\n\nconst StyledCardActions = styled(RcCardActions)`\n  width: 100%;\n  box-sizing: border-box;\n`;\n\nconst StyledCardFooter = styled.div`\n  display: flex;\n  justify-content: flex-end;\n  flex-direction: row;\n  align-items: center;\n  margin-top: 4px;\n  height: 16px;\n  width: 100%;\n  ${ellipsis}\n`;\n\nconst StyledCardAuthorAvatar = styled(RcAvatar)`\n  .RcAvatar-avatarContainer {\n    width: 12px;\n    height: 12px;\n    line-height: 12px;\n    font-size: 0.625rem;\n  }\n`;\n\nconst AuthorAvatarWrapper = styled.div`\n  margin-right: 4px;\n  display: flex;\n`;\n\nconst StyledCardContent = styled(RcCardContent)`\n  padding-bottom: 0;\n`;\n\n// Metric Card Styles\nconst MetricCardContent = styled(RcCardContent)`\n  padding: 0 !important;\n  text-align: center;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  flex: 1;\n  box-sizing: border-box;\n  \n  &:last-child {\n    padding-bottom: 0 !important;\n  }\n`;\n\nconst MetricValue = styled(RcTypography)`\n  line-height: 1;\n  margin-bottom: 8px;\n  font-weight: 600;\n`;\n\nconst MetricLabel = styled(RcTypography)`\n  text-align: center;\n  line-height: 1.2;\n  margin-bottom: 2px;\n  font-size: 0.8125rem;\n`;\n\nconst MetricUnit = styled(RcTypography)`\n  text-align: center;\n  line-height: 1.2;\n  margin-bottom: 4px;\n  font-size: 0.75rem;\n`;\n\nconst MetricComparison = styled(RcTypography)`\n  font-size: 0.75rem;\n  font-weight: 500;\n  margin-top: 2px;\n`;\n\nconst ActionArea = ({\n  children,\n  readOnly,\n  onClick,\n  disabled,\n}) => {\n  if (readOnly) {\n    return <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>{children}</div>;\n  }\n  return (\n    <RcCardActionArea \n      onClick={onClick} \n      component=\"div\" \n      disabled={disabled}\n      style={{ height: '100%', display: 'flex', flexDirection: 'column' }}\n    >\n      {children}\n    </RcCardActionArea>\n  );\n};\n\nfunction MetricCard({\n  item,\n  disabled,\n  onClick,\n  width,\n  height,\n  readOnly,\n  uiSchema,\n}) {\n  const cardStyle: {\n    backgroundColor?: string;\n    height?: string;\n  } = {};\n  if (item.backgroundColor) {\n    cardStyle.backgroundColor = item.backgroundColor;\n  }\n  if (height) {\n    cardStyle.height = height;\n  }\n  const wrapperStyle: {\n    width?: string;\n  } = {};\n  if (width) {\n    wrapperStyle.width = width;\n  }\n\n  return (\n    <StyledCardWrapper style={wrapperStyle}>\n      <StyledCard style={cardStyle}>\n        <ActionArea\n          onClick={onClick}\n          readOnly={readOnly}\n          disabled={disabled}\n        >\n          <MetricCardContent>\n            <MetricValue variant=\"title2\" color=\"neutral.f06\">{item.value || item.title}</MetricValue>\n            {item.unit && (\n              <MetricUnit variant=\"caption1\" color=\"neutral.f04\">{item.unit}</MetricUnit>\n            )}\n            <MetricLabel variant=\"body1\" color=\"neutral.f04\">{item.title || item.description || item.label}</MetricLabel>\n            {item.trend && (\n              <MetricComparison \n                color={\n                  item.trendColor || \n                  uiSchema?.['ui:trendColor']\n                }\n              >\n                {item.trend}\n              </MetricComparison>\n            )}\n          </MetricCardContent>\n        </ActionArea>\n      </StyledCard>\n    </StyledCardWrapper>\n  );\n}\n\nfunction CardItem({\n  item,\n  disabled,\n  onClick,\n  width,\n  onClickAuthor,\n  height,\n  readOnly,\n  isMetric,\n  uiSchema,\n}) {\n  // Use MetricCard component for metric layout\n  if (isMetric) {\n    return (\n      <MetricCard\n        item={item}\n        disabled={disabled}\n        onClick={onClick}\n        width={width}\n        height={height}\n        readOnly={readOnly}\n        uiSchema={uiSchema}\n      />\n    );\n  }\n\n  // Standard card layout\n  const cardStyle: {\n    backgroundColor?: string;\n    height?: string;\n  } = {};\n  if (item.backgroundColor) {\n    cardStyle.backgroundColor = item.backgroundColor;\n  }\n  if (height) {\n    cardStyle.height = height;\n  }\n  const wrapperStyle: {\n    width?: string;\n  } = {};\n  if (width) {\n    wrapperStyle.width = width;\n  }\n  let shortName = '';\n  let avatarColor;\n  if (item.authorName) {\n    const [firstName, lastName] = item.authorName.split(/\\s+/);\n    shortName = useAvatarShortName({\n      firstName,\n      lastName,\n    });\n    avatarColor = useAvatarColorToken(item.authorName);\n  }\n\n  return (\n    <StyledCardWrapper\n      style={wrapperStyle}\n    >\n      <StyledCard\n        style={cardStyle}\n      >\n        <ActionArea\n          onClick={onClick}\n          readOnly={readOnly}\n          disabled={disabled}\n        >\n          <StyledCardContent>\n            <CardTitle variant=\"body2\">{item.title}</CardTitle>\n            <StyledCardBody variant=\"caption1\" color=\"neutral.f05\">\n              {item.description}\n            </StyledCardBody>\n          </StyledCardContent>\n          <StyledCardActions>\n            <StyledCardFooter>\n              {\n                item.authorName && (\n                  <AuthorAvatarWrapper onClick={onClickAuthor}>\n                    <StyledCardAuthorAvatar\n                      size=\"xxsmall\"\n                      src={item.authorAvatar}\n                      title={item.authorName}\n                      color={avatarColor}\n                      useRcTooltip\n                    >\n                      {shortName}\n                    </StyledCardAuthorAvatar>\n                  </AuthorAvatarWrapper>\n                )\n              }\n              <RcTypography variant=\"caption1\" color=\"neutral.f05\">{item.meta}</RcTypography>\n            </StyledCardFooter>\n          </StyledCardActions>\n        </ActionArea>\n      </StyledCard>\n    </StyledCardWrapper>\n  );\n}\n\nconst StyledCardList = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  flex-direction: row;\n`;\n\nexport function List({\n  schema,\n  uiSchema,\n  disabled,\n  formData,\n  onChange,\n  onFocus,\n}) {\n  const showIconAsAvatar = \n    typeof uiSchema['ui:showIconAsAvatar'] === 'undefined' ?\n    true :\n    uiSchema['ui:showIconAsAvatar'];\n  const showAsNavigation = \n    typeof uiSchema['ui:navigation'] === 'undefined' ?\n    false :\n    uiSchema['ui:navigation'];\n  const showSelected =\n    typeof uiSchema['ui:showSelected'] === 'undefined' ?\n    true :\n    uiSchema['ui:showSelected'];\n  const readOnly =\n    typeof uiSchema['ui:readonly'] === 'undefined' ?\n    false :\n    uiSchema['ui:readonly'];\n  const itemWidget = uiSchema['ui:itemWidget'];\n  const isCard = uiSchema['ui:itemType'] === 'card' || itemWidget === 'card';\n  const isMetric = uiSchema['ui:itemType'] === 'metric' || itemWidget === 'metric';\n  const Item = isCard || isMetric ? CardItem : ListItem;\n  const Container = isCard || isMetric ? StyledCardList : StyledList;\n  return (\n    <Container>\n      {schema.oneOf.map((item) => (\n        <Item\n          key={item.const}\n          item={item}\n          disabled={disabled}\n          selected={showSelected && formData === item.const}\n          onClick={(e) => {\n            if (readOnly) {\n              return;\n            }\n            onChange(item.const);\n          }}\n          readOnly={readOnly}\n          showIconAsAvatar={showIconAsAvatar}\n          showAsNavigation={showAsNavigation}\n          width={uiSchema['ui:itemWidth']}\n          height={uiSchema['ui:itemHeight']}\n          isMetric={isMetric}\n          uiSchema={uiSchema}\n          onClickAuthor={(e) => {\n            e.stopPropagation();\n            onFocus(`${item.const}-author`, '$$clicked');\n          }}\n          actions={item.actions}\n          onClickAction={(action) => {\n            onFocus(`${action.id}-${item.const}-action`, '$$clicked');\n          }}\n        />\n      ))}\n    </Container>\n  );\n}\n","import React, { useState } from 'react';\n\nimport {\n  RcIcon,\n  RcIconButton,\n  RcTextField,\n  styled,\n  palette2,\n  RcMenu,\n  RcMenuItem,\n  RcListItemText,\n  RcButton,\n} from '@ringcentral/juno';\nimport { Search as SearchIcon, ArrowDown2 } from '@ringcentral/juno-icon';\n\nconst StyledTextField = styled(RcTextField)`\n  &.RcTextField-root {\n    margin-bottom: 0;\n  }\n\n  .RcTextFieldInput-input::placeholder {\n    font-size: 0.875rem;\n  }\n`;\n\nconst StyledSearch = styled(StyledTextField)`\n  &.RcTextField-root {\n    flex: 1;\n  }\n\n  .RcTextFieldInput-input {\n    font-size: 0.75rem;\n    line-height: 16px;\n    margin-left: 8px;\n  }\n\n  .RcTextFieldInput-root {\n    padding: 5px 0;\n  }\n\n  .RcOutlineTextFieldInput-root::before {\n    box-shadow: none;\n  }\n\n  .RcOutlineTextFieldInput-root:not(.RcOutlineTextFieldInput-focused):not(.RcOutlineTextFieldInput-disabled):hover {\n    background: ${palette2('neutral', 'b01')};\n  }\n\n  .MuiInput-underline:hover:not(.Mui-disabled):before {\n    border-bottom: none;\n  }\n\n  .MuiInput-underline:after {\n    border-bottom: none;\n  }\n\n  .RcTextFieldInput-underline:before {\n    border-bottom: none;\n  }\n\n  .RcTextFieldInput-input::placeholder {\n    font-size: 0.75rem;\n  }\n`;\n\nconst SearchAndFilterContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  border-bottom: 1px solid ${palette2('neutral', 'l02')};\n\n  &:hover {\n    border-bottom: 1px solid ${palette2('neutral', 'l03')};\n  }\n\n  &:focus-within {\n    border-bottom: 1px solid ${palette2('interactive', 'b02')};\n  }\n`;\n\nconst StyledTypeFilterRoot = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n`;\n\nconst StyledFilterIcon = styled(RcIconButton)`\n  .icon {\n    font-size: 1rem;\n  }\n`;\n\nfunction TypeFilter({\n  type,\n  onTypeChange,\n  typeList,\n  previewLength = 2,\n}) {\n  const [menuOpen, setMenuOpen] = useState(false);\n  const [anchorEl, setAnchorEl] = useState(null);\n  let previewTypes = typeList.slice(0, previewLength);\n  let restTypes = typeList.slice(previewLength);\n  if (previewLength === 1) {\n    previewTypes = [type];\n    restTypes = typeList;\n  } else if (previewTypes.indexOf(type) === -1) {\n    const lastPreviewType = previewTypes[previewTypes.length - 1];\n    previewTypes[previewTypes.length - 1] = type;\n    restTypes = restTypes.filter((t) => t !== type);\n    restTypes = [lastPreviewType, ...restTypes];\n  }\n  return (\n    <StyledTypeFilterRoot>\n      {previewTypes.map((t) => (\n        <RcButton\n          key={t}\n          variant='text'\n          size=\"xsmall\"\n          color={type === t ? 'action.primary' : 'neutral.f05'}\n          onClick={() => onTypeChange(t)}\n        >\n          {t}\n        </RcButton>\n      ))}\n      {\n        restTypes.length > 0 && (\n          <>\n            <StyledFilterIcon\n              symbol={ArrowDown2}\n              variant='round'\n              radius={4}\n              size=\"xsmall\"\n              innerRef={setAnchorEl}\n              onClick={() => {\n                setMenuOpen(true);\n              }}\n            />\n            <RcMenu\n              anchorEl={anchorEl}\n              open={menuOpen}\n              onClose={() => setMenuOpen(false)}\n            >\n              {\n                restTypes.map((t) => (\n                  <RcMenuItem\n                    key={t}\n                    onClick={() => {\n                      onTypeChange(t);\n                      setMenuOpen(false);\n                    }}\n                    selected={type === t}\n                  >\n                    <RcListItemText\n                      primary={t}\n                    />\n                  </RcMenuItem>\n                ))\n              }\n            </RcMenu>\n          </>\n        )\n      }\n    </StyledTypeFilterRoot>\n  );\n}\n\nexport function Search({\n  uiSchema,\n  formData,\n  disabled,\n  onChange,\n}) {\n  const placeholder = uiSchema['ui:placeholder'] || 'Search';\n  const helperText = uiSchema['ui:helpText'] || '';\n  const filterTypes = uiSchema['ui:filters'] || [];\n  if (filterTypes.length > 0) {\n    const searchText = formData ? formData.search : '';\n    let previewLength = searchText.length > 0 ? 1 : 2;\n    if (uiSchema['ui:previewLength']) {\n      previewLength = uiSchema['ui:previewLength'];\n    }\n    return (\n      <SearchAndFilterContainer>\n        <StyledSearch\n          variant=\"outline\"\n          value={searchText}\n          disabled={disabled}\n          InputProps={{\n            startAdornment: <RcIcon symbol={SearchIcon} size=\"small\" />,\n          }}\n          placeholder={placeholder}\n          onChange={(e) => onChange({\n            ...formData,\n            search: e.target.value,\n          })}\n          fullWidth\n        />\n        <TypeFilter\n          type={formData ? formData.filter : ''}\n          onTypeChange={(filter) => onChange({\n            ...formData,\n            filter,\n          })}\n          typeList={filterTypes}\n          previewLength={previewLength}\n        />\n      </SearchAndFilterContainer>\n    );\n  }\n  return (\n    <StyledTextField\n      variant=\"outline\"\n      value={formData}\n      disabled={disabled}\n      size=\"small\"\n      radius=\"round\"\n      InputProps={{\n        startAdornment: <RcIcon symbol={SearchIcon} size=\"small\" />,\n      }}\n      placeholder={placeholder}\n      onChange={(e) => onChange(e.target.value)}\n      fullWidth\n      gutterBottom\n      helperText={helperText}\n    />\n  )\n}\n"],"names":[],"sourceRoot":""}