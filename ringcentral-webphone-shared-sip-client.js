!function(){"use strict";var deferred,next,__webpack_modules__={31899:function(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__){var event_emitter=__webpack_require__(773157),rc_message=__webpack_require__(454793),inbound=__webpack_require__(946506),outbound=__webpack_require__(360224),request=__webpack_require__(574317),response=__webpack_require__(822329),utils=__webpack_require__(954851);const logger=new class{log(message){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];console.log("[INFO] WEBPHONE ",message,...args)}warn(message){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];console.warn("[WARN] WEBPHONE ",message,...args)}error(message){for(var _len3=arguments.length,args=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++)args[_key3-1]=arguments[_key3];console.error("[ERROR] WEBPHONE ",message,...args)}debug(message){for(var _len4=arguments.length,args=new Array(_len4>1?_len4-1:0),_key4=1;_key4<_len4;_key4++)args[_key4-1]=arguments[_key4];console.log("[DEBUG] WEBPHONE ",message,...args)}};class Transport extends event_emitter.A{constructor(_ref){let{sipInfo:sipInfo}=_ref;if(super(),this.wsc=void 0,this.logger=void 0,this.status="disconnected",this.disposed=!1,this.debug=void 0,this.wsServers=[],this.currentServer=null,this.connectTimeoutHandle=void 0,this._connectPromise=null,this.reconnectionAttempts=0,this.maxReconnectionAttempts=10,this.reconnectionTimeout=4,this.connectionTimeout=5,this.onMessage=void 0,this.onClose=void 0,this.reconnectTimeoutHandle=void 0,this.disposed=!1,this.logger=logger,this.currentServer=null,this.reconnectionAttempts=0,this.maxReconnectionAttempts=1===this.wsServers.length?15:10,this.reconnectionTimeout=1===this.wsServers.length?10:4,this.connectionTimeout=5,sipInfo.outboundProxy&&this.wsServers.push({server:sipInfo.outboundProxy,isError:!1,backup:!1}),sipInfo.outboundProxyBackup&&this.wsServers.push({server:sipInfo.outboundProxyBackup,isError:!1,backup:!0}),0===this.wsServers.length)throw new Error("No available servers");this.onMessage=event=>{this.emit("message",event)}}setStatus(status){this.status=status,this.emit("status",status)}async connect(){let forceMain=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._connectPromise)return this._connectPromise;try{this._connectPromise=this._connect(forceMain),await this._connectPromise,this.setStatus("connected"),this._connectPromise=null}catch(e){this.logger.error("Connect failed",e),this.setStatus("reconnecting"),this._connectPromise=null,await this.reconnect()}}async _connect(forceMain){if(this.currentServer=this.currentServer||this.getNextServer(forceMain),!this.currentServer)throw new Error("No available servers");if(this.logger.log("Connecting to server",this.currentServer.server),"disconnected"!==this.status&&this.wsc&&(this.logger.warn("Attempted to connect while connected, disconnecting"),await this.disconnect()),this.setStatus("connecting"),this.wsc=new WebSocket("wss://"+this.currentServer.server,"sip"),this.debug){const wscSend=this.wsc.send.bind(this.wsc);this.wsc.send=message=>(this.logger.log(`Sending...(${new Date})\n`+message),wscSend(message))}return new Promise(((resolve,reject)=>{const openEventHandler=()=>{this.wsc.removeEventListener("open",openEventHandler),this.wsc.removeEventListener("error",errorEventHandler),clearTimeout(this.connectTimeoutHandle),this.wsc.addEventListener("message",this.onMessage),resolve()},errorEventHandler=e=>{this.wsc.removeEventListener("error",errorEventHandler),this.wsc.removeEventListener("message",this.onMessage),clearTimeout(this.connectTimeoutHandle),this.wsc=null,reject(e)};this.connectTimeoutHandle=setTimeout((()=>{this.logger.log("Connection timeout, closing connection"),this.wsc.removeEventListener("open",openEventHandler),this.wsc.removeEventListener("error",errorEventHandler),this.wsc.removeEventListener("message",this.onMessage),reject(new Error("Connection timeout")),this.wsc.close(),this.wsc=null}),1e3*this.connectionTimeout),this.wsc.addEventListener("open",openEventHandler),this.wsc.addEventListener("error",errorEventHandler)}))}getComputeRandomTimeout(reconnectionAttempts,randomMinInterval,randomMaxInterval){return Math.floor(Math.random()*Math.abs(randomMaxInterval-randomMinInterval))+randomMinInterval+(reconnectionAttempts-1)*(randomMinInterval+randomMaxInterval)/2}async reconnect(){let forceMain=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.reconnectionAttempts>0&&this.logger.warn("Reconnect attempt",this.reconnectionAttempts),forceMain)return await this.disconnect(),this.currentServer=this.getNextServer(!0),this.reconnectionAttempts=0,void await this.connect();if(this.noAvailableServers())return this.logger.warn("No available servers"),this.setStatus("error"),this.reconnectionAttempts=0,void(this.currentServer=this.getNextServer(!0));if("reconnecting"!==this.status&&"disconnected"!==this.status&&this.wsc)return this.logger.warn("Attempted to reconnect while connected, disconnecting"),await this.disconnect(),void await this.reconnect();this.reconnectionAttempts++;const nextReconnectInterval=this.getComputeRandomTimeout(this.reconnectionAttempts,1e3*(this.reconnectionTimeout-2),1e3*(this.reconnectionTimeout+2));if(this.reconnectionAttempts>this.maxReconnectionAttempts)return this.logger.warn("Max reconnection attempts reached for server",this.currentServer.server),this.currentServer.isError=!0,this.reconnectionAttempts=0,this.currentServer=this.getNextServer(),void await this.reconnect();this.logger.warn("Reconnect attempt",this.reconnectionAttempts,"next reconnect in",nextReconnectInterval),this.reconnectTimeoutHandle&&clearTimeout(this.reconnectTimeoutHandle),this.reconnectTimeoutHandle=setTimeout((()=>{this.connect()}),nextReconnectInterval)}disconnect(){this._disconnect()}_disconnect(){this.wsc&&"disconnected"!==this.status?(this.logger.log("Transport disconnected"),this.setStatus("disconnected"),this.wsc.removeEventListener("message",this.onMessage),this.wsc.close(),this.wsc=null,this.currentServer=null,this.reconnectionAttempts=0):this.logger.warn("Transport is already disconnected")}noAvailableServers(){for(const server of this.wsServers)if(!server.isError)return!1;return!0}getNextServer(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])return this.wsServers[0];for(const server of this.wsServers)if(!server.isError)return server;return this.wsServers[0]}dispose(){this.disposed?this.logger.warn("Transport is already disposed"):(this.logger.log("Disposing Transport"),this.disposed=!0,this.reconnectTimeoutHandle&&clearTimeout(this.reconnectTimeoutHandle),this.removeAllListeners(),this._disconnect(),this.logger.log("Transport disposed"))}}class SharedWorkerSipClient extends event_emitter.A{constructor(){let{debug:debug=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this.transport=void 0,this.logger=void 0,this.sipInfo=void 0,this.device=void 0,this.instanceId=void 0,this.debug=void 0,this.status="unregistered",this.clientId=void 0,this.timeoutHandle=void 0,this.debug=debug,this.status="unregistered",this.logger=logger}setStatus(status,error){this.status=status,this.emit("status",status,null==error?void 0:error.message)}async start(_ref2){let{sipInfo:sipInfo,instanceId:instanceId,device:device,clientId:clientId,force:force=!1,debug:debug}=_ref2;!this.transport||this.sipInfo.authorizationId!==sipInfo.authorizationId||this.sipInfo.domain!==sipInfo.domain||this.sipInfo.username!==sipInfo.username||this.sipInfo.password!==sipInfo.password||this.sipInfo.outboundProxy!==sipInfo.outboundProxy||this.sipInfo.outboundProxyBackup!==sipInfo.outboundProxyBackup||"registered"!==this.status&&"registering"!==this.status||this.clientId!==clientId||force?(this.logger.log("Starting SipClient"),this.sipInfo=sipInfo,this.device=device,this.instanceId=null!=instanceId?instanceId:sipInfo.authorizationId,this.debug=debug||!1,this.clientId=clientId,this.transport&&(this.logger.warn("There is a transport, disposing it"),this.transport.dispose()),this.logger.log("Creating new transport"),this.transport=new Transport({sipInfo:sipInfo}),this.transport.on("message",(async event=>{const inboundMessage=inbound.A.fromString(event.data);if(inboundMessage.subject.startsWith("MESSAGE sip:")){const rcMessage=await rc_message.A.fromXml(inboundMessage.body);if(rcMessage.body.Cln&&rcMessage.body.Cln!==this.sipInfo.authorizationId)return}this.debug&&this.logger.log(`Receiving...(${new Date})\n`+event.data),this.emit("inboundMessage",inboundMessage),(inboundMessage.subject.startsWith("MESSAGE sip:")||inboundMessage.subject.startsWith("BYE sip:")||inboundMessage.subject.startsWith("CANCEL sip:")||inboundMessage.subject.startsWith("INFO sip:")||inboundMessage.subject.startsWith("NOTIFY sip:"))&&await this.reply(new response.A(inboundMessage,{responseCode:200}))})),this.timeoutHandle&&clearTimeout(this.timeoutHandle),this.setStatus("registering"),this.transport.on("status",(async status=>{this.logger.log("Transport status",status),this.emit("transportStatus",status),"connected"===status&&(this.logger.log("Transport connected, registering"),this.register(60))})),await this.transport.connect()):this.logger.warn("SipClient already started, current status:",this.status)}async dispose(){if("unregistered"!==this.status&&"unregistering"!==this.status){this.logger.log("Disposing SipClient");try{var _this$transport;clearTimeout(this.timeoutHandle),await this.unregister(),await(null===(_this$transport=this.transport)||void 0===_this$transport?void 0:_this$transport.dispose()),this.transport=null,this.logger.log("SipClient disposed")}catch(e){var _this$transport2;return this.logger.error("SipClient dispose failed",e),this.setStatus("registrationError"),await(null===(_this$transport2=this.transport)||void 0===_this$transport2?void 0:_this$transport2.dispose()),void(this.transport=null)}}else this.logger.warn("SipClient is already disposed, current status:",this.status)}async register(expires){try{this.setStatus(expires>0?"registering":"unregistering"),await this._register(expires),this.setStatus(expires>0?"registered":"unregistered")}catch(e){expires>0?(this.logger.error("Registration failed",e),this.setStatus("registrationError",e)):this.setStatus("unregistered")}}async _register(expires){this.logger.log("Registering with instanceId",this.instanceId);const requestMessage=new request.A(`REGISTER sip:${this.sipInfo.domain} SIP/2.0`,{"Call-Id":(0,utils.uR)(),Contact:`<sip:${utils.K4};transport=wss>;+sip.instance="<urn:uuid:${this.instanceId}>";expires=${expires}`,From:`<sip:${this.sipInfo.username}@${this.sipInfo.domain}>;tag=${(0,utils.uR)()}`,To:`<sip:${this.sipInfo.username}@${this.sipInfo.domain}>`,Via:`SIP/2.0/WSS ${utils.Yn};branch=${(0,utils.tk)()}`,"Client-id":this.clientId}),requestPromise=new Promise(((resolve,reject)=>{const closeHandle=setTimeout((()=>{this.logger.warn("Registration timeout"),reject(new Error("Registration timeout"))}),8e3);this.request(requestMessage).then((m=>{this.logger.log("Registration request resolved, clearing timeout"),clearTimeout(closeHandle),resolve(m)})).catch((e=>{this.logger.error("Registration request rejected:",e),clearTimeout(closeHandle),reject(e)}))}));this.logger.log("Sending registration request");let inboundMessage=await requestPromise;this.logger.log("Received registration response");const wwwAuth=inboundMessage.headers["Www-Authenticate"]||inboundMessage.headers["WWW-Authenticate"];if(wwwAuth){const nonce=wwwAuth.match(/, nonce="(.+?)"/)[1],newMessage=requestMessage.fork();newMessage.headers.Authorization=(0,utils.ju)(this.sipInfo,nonce,"REGISTER"),inboundMessage=await this.request(newMessage)}else if(inboundMessage.subject.startsWith("SIP/2.0 603 "))throw new Error("Registration failed: "+inboundMessage.subject);if(expires>0){const serverExpires=Number(inboundMessage.headers.Contact.match(/;expires=(\d+)/)[1]);this.timeoutHandle&&clearTimeout(this.timeoutHandle),this.timeoutHandle=setTimeout((()=>{this.register(expires)}),1e3*(serverExpires-3))}}async unregister(){this.logger.log("Unregistering"),await this.register(0),this.logger.log("Unregistered")}async request(message){return await this._send(message,!0)}async reply(message){await this._send(message,!1)}_send(rawMessage){let message,waitForReply=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return"string"==typeof rawMessage?(this.transport.wsc.send(rawMessage),message=outbound.A.fromString(rawMessage)):(this.transport.wsc.send(rawMessage.toString()),message=rawMessage),this.emit("outboundMessage",message),new Promise(waitForReply?resolve=>{const messageListerner=inboundMessage=>{inboundMessage.headers.CSeq===message.headers.CSeq&&(inboundMessage.subject.startsWith("SIP/2.0 100 ")||(this.off("inboundMessage",messageListerner),resolve(inboundMessage)))};this.on("inboundMessage",messageListerner)}:resolve=>{resolve(new inbound.A)})}}const sipClient=new SharedWorkerSipClient;let mainPort,ports=[],sharedState={};onconnect=event=>{logger.log("port onconnect");const port=event.ports[0];ports.push(port),1===ports.length&&(logger.log("set first port as mainPort"),mainPort=port),port.onmessage=async event=>{const{type:type,requestId:requestId,request:request}=event.data;if("destroyPort"===type)return logger.log("destroyPort"),ports=ports.filter((p=>p!==port)),mainPort===port&&(mainPort=ports[0]||null,logger.log("mainPort is destroyed, set new mainPort")),void(0===ports.length&&(logger.log("No ports left, disposing SipClient"),await sipClient.dispose()));if("setActive"===type){const activeTabId=event.data.activeTabId;logger.log("setActive",activeTabId),mainPort=port,ports.find((p=>p===port))||(logger.warn("no port found when active, add port to ports"),ports.push(port)),ports.forEach((p=>{p!==port&&p.postMessage({type:"setActive",activeTabId:activeTabId})}))}if("setSharedState"!==type){if("workerRequest"===type){if("getSharedState"===request.type)return void port.postMessage({type:"workerResponse",requestId:requestId,response:sharedState});if("getSipClientStatus"===request.type)return void port.postMessage({type:"workerResponse",requestId:requestId,response:{status:sipClient.status,sipInfo:sipClient.sipInfo,device:sipClient.device,instanceId:sipClient.instanceId}});if("startSipClient"===request.type)return mainPort||(logger.warn("No main port, set current port as main port"),mainPort=port,ports.find((p=>p===port))||ports.push(port)),logger.log("Received startSipClient request"),await sipClient.start(request.data),void port.postMessage({type:"workerResponse",requestId:requestId,response:"OK"});if("request"===request.type){try{const response=await sipClient.request(request.data);port.postMessage({type:"workerResponse",requestId:requestId,response:response.toString()})}catch(e){port.postMessage({type:"workerResponse",requestId:requestId,error:e.message||"Unknown error"})}return}if("reply"===request.type){try{await sipClient.reply(request.data),port.postMessage({type:"workerResponse",requestId:requestId,response:"OK"})}catch(e){port.postMessage({type:"workerResponse",requestId:requestId,error:e.message||"Unknown error"})}return}if("register"===request.type)return logger.log("Received register request"),await sipClient.register(request.data),void port.postMessage({type:"workerResponse",requestId:requestId,response:"OK"});if("unregister"===request.type)return logger.log("Received unregister request"),await sipClient.dispose(),void port.postMessage({type:"workerResponse",requestId:requestId,response:"OK"});port.postMessage({type:"workerResponse",requestId:requestId,response:"NOT_SUPPORTED"})}}else{const state=event.data.state;state&&(Object.keys(state).forEach((key=>{sharedState[key]=state[key]})),ports.forEach((p=>{p!==port&&p.postMessage({type:"setSharedState",state:state})})))}}},sipClient.on("inboundMessage",(message=>{let port=mainPort;port||(port=ports[0]),port?(logger.log("Received inboundMessage, sending to main port"),port.postMessage({type:"inboundMessage",message:message.toString()})):logger.warn("No main port, skipping inboundMessage")})),sipClient.on("outboundMessage",(message=>{let port=mainPort;port||(port=ports[0]),port?(logger.log("Sending outboundMessage to main port"),port.postMessage({type:"outboundMessage",message:message.toString()})):logger.warn("No main port, skipping outboundMessage")})),sipClient.on("status",((status,error)=>{logger.log("sipClient status changed, sync to ports",status,error),ports.forEach((port=>{port.postMessage({type:"status",status:status,error:error})}))})),sipClient.on("transportStatus",(status=>{logger.log("sipClient transportStatus changed, sync to ports",status),ports.forEach((port=>{port.postMessage({type:"transportStatus",status:status})}))})),self.sipClient=sipClient}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.x=function(){var __webpack_exports__=__webpack_require__.O(void 0,[832],(function(){return __webpack_require__(31899)}));return __webpack_exports__=__webpack_require__.O(__webpack_exports__)},deferred=[],__webpack_require__.O=function(result,chunkIds,fn,priority){if(!chunkIds){var notFulfilled=1/0;for(i=0;i<deferred.length;i++){chunkIds=deferred[i][0],fn=deferred[i][1],priority=deferred[i][2];for(var fulfilled=!0,j=0;j<chunkIds.length;j++)(!1&priority||notFulfilled>=priority)&&Object.keys(__webpack_require__.O).every((function(key){return __webpack_require__.O[key](chunkIds[j])}))?chunkIds.splice(j--,1):(fulfilled=!1,priority<notFulfilled&&(notFulfilled=priority));if(fulfilled){deferred.splice(i--,1);var r=fn();void 0!==r&&(result=r)}}return result}priority=priority||0;for(var i=deferred.length;i>0&&deferred[i-1][2]>priority;i--)deferred[i]=deferred[i-1];deferred[i]=[chunkIds,fn,priority]},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,{a:getter}),getter},__webpack_require__.d=function(exports,definition){for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},__webpack_require__.f={},__webpack_require__.e=function(chunkId){return Promise.all(Object.keys(__webpack_require__.f).reduce((function(promises,key){return __webpack_require__.f[key](chunkId,promises),promises}),[]))},__webpack_require__.u=function(chunkId){return chunkId+".js"},__webpack_require__.miniCssF=function(chunkId){},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=function(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)},function(){var scriptUrl;__webpack_require__.g.importScripts&&(scriptUrl=__webpack_require__.g.location+"");var document=__webpack_require__.g.document;if(!scriptUrl&&document&&(document.currentScript&&"SCRIPT"===document.currentScript.tagName.toUpperCase()&&(scriptUrl=document.currentScript.src),!scriptUrl)){var scripts=document.getElementsByTagName("script");if(scripts.length)for(var i=scripts.length-1;i>-1&&(!scriptUrl||!/^http(s?):/.test(scriptUrl));)scriptUrl=scripts[i--].src}if(!scriptUrl)throw new Error("Automatic publicPath is not supported in this browser");scriptUrl=scriptUrl.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=scriptUrl}(),function(){var installedChunks={464:1};__webpack_require__.f.i=function(chunkId,promises){installedChunks[chunkId]||importScripts(__webpack_require__.p+__webpack_require__.u(chunkId))};var chunkLoadingGlobal=self.webpackChunkringcentral_embeddable=self.webpackChunkringcentral_embeddable||[],parentChunkLoadingFunction=chunkLoadingGlobal.push.bind(chunkLoadingGlobal);chunkLoadingGlobal.push=function(data){var chunkIds=data[0],moreModules=data[1],runtime=data[2];for(var moduleId in moreModules)__webpack_require__.o(moreModules,moduleId)&&(__webpack_require__.m[moduleId]=moreModules[moduleId]);for(runtime&&runtime(__webpack_require__);chunkIds.length;)installedChunks[chunkIds.pop()]=1;parentChunkLoadingFunction(data)}}(),next=__webpack_require__.x,__webpack_require__.x=function(){return __webpack_require__.e(832).then(next)};__webpack_require__.x()}();